; Программа, работающая с числами типа WORD (2-байтовыми)

.model small
.486						; поддержка инструкций процессора 486
.stack 100h					; стек на 256 байт

.data

WS		=	2			; размер элемента (2 байта)
Src		DW	55, -1, 7, -2000, 18000, 2, -38, -317	; данные
Count		=	($-Src)/WS		; кол-во элементов массива
Dest		DW	Count dup (?)		; буфер под новый массив

.code

Start:

		mov	ax,@data
		mov	ds,ax			; DS = сегмент данных

		mov	ax,[Src]		; AX = первый элемент массива
		mov	dx,[Src+(Count-1)*WS]	; DX = последний элемент массива
		cmp	ax,dx			; сравниваем их
		jle	MinAX			; если AX <= DX, прыгаем
		xchg	ax,dx			; иначе меняем значения местами, чтобы в AX был меньший элемент, а в DX больший
	MinAX:	push	ax			; сохраняем в стеке меньший элемент (среди первого и последнего)
		push	dx			; сохраняем в стеке больший элемент (потом они понадобятся)

		lea	si,Src			; адрес исходного массива
		mov	cx,Count		; кол-во чисел
		call	ShowArray		; выводим на экран

		; Обработка исходного массива (Src)
	Repeat:	lea	si,Src			; SI = начало исходного массива, индексный регистр (для индексной адресации)
		xor	bx,bx			; BX = 0 (обмена значений пока не было)
		mov	cx,Count-1		; CX = кол-во элементов массива минус 1
		jcxz	MakeNew			; если массив состоит из 1 элемента, его обрабатывать ненужно (прыгаем)
	CompNext:
		mov	ax,[si]			; AX = элемент массива
		mov	dx,[si+WS]		; DX = следующий элемент массива
		cmp	ax,dx			; сравниваем их
		jle	SkipSwap		; если AX <= DX, прыгаем
		mov	bp,ax
		or	bp,dx			; BP = AX or DX (нас интересует только старший бит, т.к. у отрицательных чисел старший бит установлен в 1, у положительных - сброшен в 0)
		jns	SkipSwap		; если старший бит BP = 0, значит оба числа положительные, менять их не надо, прыгаем
		mov	[si],dx			; иначе (если AX >= DX и хотя бы одно из чисел отрицательное), меняем...
		mov	[si+WS],ax		; ...их местами
		inc	bx			; увеличиваем счётчик обменов
	SkipSwap:
		add	si,WS			; переходим к следующему числу (добавляем к SI размер числа)
		loop	CompNext		; повторяем цикл CX раз

		test	bx,bx			; проверяем BX (кол-во обменов)
		jnz	Repeat			; повторяем процесс, если BX <> 0 (если был хотя бы один обмен)
	MakeNew:

		lea	si,Src			; адрес исходного массива
		mov	cx,Count		; кол-во чисел
		call	ShowArray		; выводим на экран
		
		; Формируем новый массив
		lea	si,Src			; SI = начало исходного массива, индексный регистр (для индексной адресации)
		lea	bx,Dest			; BX = начало нового массива, базовый регистр (для базовой адресации)
		pop	dx			; DX = восстанавливаем из стека верхнюю границу значений, который не подходят для нового массива
		pop	ax			; AX = восстанавливаем из стека нижнюю границу значений, который не подходят для нового массива
		mov	cx,Count		; CX = кол-во элементов массива
	CheckNext:
		mov	bp,[si]			; BP = очередной элемент массива
		cmp	bp,ax			; сравниваем значение с минимальным
		jl	Ok			; прыгаем, если оно меньше (т.е. подходит)
		cmp	bp,dx			; сравниваем значение с максимальным
		jng	BadNumber		; прыгаем, если оно НЕ больше (т.е. НЕ подходит)
	Ok:	mov	[bx],bp			; иначе записываем число (которое не попадает в интервал от AX до DX) в новый массив
		add	bx,WS			; переходим к следующему числу нового массива (добавляем к BX размер числа)
	BadNumber:
		add	si,WS			; переходим к следующему числу исходного массива (добавляем к SI размер числа)
		loop	CheckNext		; повторяем цикл CX раз (обрабатывая все элементы массива)

		; Завершение
		mov	cx,bx			; CX = адрес элемента, следующего за последним, в новом массиве
		sub	cx,offset Dest		; CX = размер массива в байтах (вычитаем адрес начала)
		shr	cx,1			; делим CX на 2 (размер слова) в помощью сдвига справо
		; Итого в CX имеем размер нового массива
		lea	si,Dest			; адрес нового массива
		call	ShowArray		; выводим на экран

		mov	ax,4C00h
		int	21h			; выходим из программы

;-- Вывод на экран массива по адресу DS:SI (CX чисел) ----------------------------------------------
; Сохраняет все регистры
ShowArray	proc
		cld			; прямой порядок обработки массива
		pusha			; сохраняем все регистры
	NextNum:
		lodsw			; читаем очередное число в AX
		push	cx		; сохраняем CX
		call	OutInt		; выводим число
		mov	ah,2
		mov	dl,' '
		int	21h		; выводим пробел
		pop	cx		; восстанавливаем CX
                loop	NextNum		; повтоярем цикл CX раз
                mov	ah,2
                mov	dl,13
                int	21h
                mov	dl,10
                int	21h		; переход на новую строку
		popa			; восстанавливаем все регистры
		ret			; выходим из процедуры
ShowArray	endp

;-- Вывод целого знакового десятичного числа (AX) на экран -----------------------------------------
; Меняет AX, BX, CX, DX
OutInt		proc
		test	ax,ax		; проверяем число
		jns	nosign		; переходим, если число положительное
		push	ax		; иначе сохраняем число
		mov	ah,2		; номер функции DOS вывода символа на экран
		mov	dl,'-'		; символ
		int	21h		; выводим символ
		pop	ax		; восстанавливаем число
		neg	ax		; и меняем знак
	nosign:
		xor	cx,cx		; кол-во цифр (пока 0)
		mov	bx,10		; система счисления (десятичная)
	nextdigit:
		xor	dx,dx		; DS = 0 (нужно для деления)
		div	bx		; AX = DX:AX/систему_счисления, DX = остаток
		push	dx		; сохраняем цифру в стеке
		inc	cx		; увеличиваем кол-во цифр
		test	ax,ax		; проверяем AX (число)
		jnz	nextdigit	; переход, если частное ещё не равно 0
		mov	ah,2		; номер функции DOS вывода символа на экран
	outdigit:
		pop	dx		; извлекаем цифру из стека
		add	dl,'0'		; преобразуем её в символ
		int	21h		; вывод цифры
		loop	outdigit	; повторяем цикл вывода символов
		ret			; выходим из процедуры
OutInt		endp

end		Start				; Start - точка старта
