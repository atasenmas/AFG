.MODEL Tiny
.286
.CODE
ORG	100h

Func2F		=	0FFh		; номер функции int 2Fh (любое значение от 0C0h до 0FFh)
Request2F	=	'FO'		; запрос в регистре BX
Answer2F	=	'fo'		; ответ в регистре BX в случае успеха
ColNum		=	64		; кол-во цветов

Start:

		jmp	SetIntVec	; прыжок на установщик вектора

Brightness	db	63		; текущая яркость значение (от 0 до 63)
Delta		db	-1		; узменение яркости (1 или -1)
Palette		db	ColNum*3 dup (?)  ; значения цветовой палитры для каждого из ColNum цветов

; Обработчик прерывания 8 (прерывание от таймера)
Handler8:

		pusha			; сохраняем все регистры общего назначения
		push	ds		; сохраняем DS
		push	cs
		pop	ds		; DS = CS
		mov	dl,Brightness	; читаем яркость
		add	dl,Delta	; меняем яркость на Delta
		test	dl,dl
		jz	@@NegDelta	; прыгаем, если Delta = 0
		cmp	dl,63
		jb	@@DeltaOk	; прыгаем, если Delta < 63
	@@NegDelta:
		neg	Delta		; меняем знак Delta
	@@DeltaOk:
		mov	Brightness,dl	; записываем яркость обратно
		; Установка новой палитры цветов для первых ColNum цветов (DL=яркость)
		cld			; прямой порядок работы со строками
		lea	si,Palette	; адрес палитры
		xor	bx,bx		; номер первого цвета
		mov	cx,ColNum	; кол-во цветов
	@@NextCol:
		push	cx
		mov	cl,63		; делитель
		lodsb			; читаем красный цвет
		mul	dl		; умножаем на яркость (DL)
		div	cl		; делим на 63, получаем нужную яркость в AL
		mov	dh,al		; записываем цвет
		lodsb			; читаем зелёный цвет
		mul	dl		; умножаем на яркость (DL)
		div	cl		; делим на 63, получаем нужную яркость в AL
		mov	ch,al		; записываем цвет
		lodsb			; читаем синий цвет
		mul	dl		; умножаем на яркость (DL)
		div	cl		; делим на 63, получаем нужную яркость в AL
		mov	cl,al		; записываем цвет
		mov	ax,1010h	; функция VGA установки палитры одного цвета
		int	10h		; устанавливаем палитру для цвета BX
		pop	cx
		inc	bx		; увеличиваем номер цвета
		loop	@@NextCol	; переходим к следующему цвету

		pop	ds		; восстанавливаем DS
		popa			; восстанавливаем все регистры общего назначения
RealInt8:	db	0EAh		; jmp far - переходим к старому обработчику прерывания 8
RealAddr8	dw	?,?		; адерес прыжка (старого обработчика прерывания)

;----------------------------------------------------------------------------;

; Обработчик прерывания 2Fh (сервисное прерывание)
Handler2F:
		; Проверка запроса
		cmp	ah,Func2F	; проверяем номер функции
		jne	RealInt2F	; прыгаем, если не наша
		cmp	bx,Request2F	; проверяем запрос
		jne	RealInt2F	; прыгаем, если не наш
		test	al,al		; проверяем номер подфункции
		jz	@@Answer	; прыгаем, если AL=0 (получить информацию об установке)
		cmp	al,80h		; проверяем номер подфункции 80h (выгрузить из памяти)
		jne	RealInt2F	; прыгаем, если AL<>80h
		; Выгрузка программы из памяти
		push	ds
		pusha			; сохраняем DS и регистры общего назначения
		push	0
		pop	ds		; DS = 0 (нулевой сегмент, где хранится таблица обработчиков прерываний)
		mov	ax,cs		; AX = CS (сегмент кода)
		cmp	ds:[8*4+2],ax	; в таблице обработчика int 8 сегмент = сегменту нашего обработчика (AX)?
		jne	@@UninstError	; прыгаем, если нет (прерывание перехвачено другой программой, выгрузка невозможна)
		cmp	ds:[8*4],offset Handler8  ; в таблице обработчика int 8 смещение = смещению нашего обработчика?
		jne	@@UninstError	; прыгаем, если нет (прерывание перехвачено другой программой, выгрузка невозможна)
		cmp	ds:[2Fh*4+2],ax	; в таблице обработчика int 2Fh сегмент = сегменту нашего обработчика (AX)?
		jne	@@UninstError	; прыгаем, если нет (прерывание перехвачено другой программой, выгрузка невозможна)
		cmp	ds:[2Fh*4],offset Handler2F  ; в таблице обработчика int 2Fh смещение = смещению нашего обработчика?
		jne	@@UninstError	; прыгаем, если нет (прерывание перехвачено другой программой, выгрузка невозможна)
		; Если оба обработчика прерывания в таблице указывают на наши обработчики, то начинаем выгрузку нашей программы...
		; Восстанавливаем старые обработчики прерываний
		push	es		; сохраняем ES
		les	ax,dword ptr cs:RealAddr8   ; ES:AX = адрес обработчика int 8
		mov	ds:[8*4],ax	; восстанавливаем смещение старого обработчика int 8
		mov	ds:[8*4+2],es	; восстанавливаем сегмент старого обработчика int 8
		les	ax,dword ptr cs:RealAddr2F  ; ES:AX = адрес обработчика int 2Fh
		mov	ds:[2Fh*4],ax	; восстанавливаем смещение старого обработчика int 2Fh
		mov	ds:[2Fh*4+2],es	; восстанавливаем сегмент старого обработчика int 2Fh
		; Восстанавливаем исходную палитру цветов
		push	cs
		pop	es		; ES = CS
		mov	ax,1012h	; функция VGA установки палитры цветов (блоком)
		xor	bx,bx		; номер первого цвета (0)
		mov	cx,ColNum	; кол-во цветов
		lea	dx,Palette	; буфер с плитрой
		int	10h		; восстанавливаем палитру
		; Выгружаем программу
		mov	ah,49h		; функция освобождения памяти
		int	21h		; освобождаем память, занятую нашей программой
		; Всё, программа выгружена
		pop	es
		popa			; восстанавливаем ES, регистры общего назначения
		xor	al,al		; AL = 0 - успешная выгрузка
		jmp	@@UninstOk	; прыгаем на завершение
	@@UninstError:
		popa			; восстанавливаем регистры общего назначения
		mov	al,-1		; устанавливаем AL = -1 - выгрузка невозможна
	@@UninstOk:
		pop	ds		; восстанавливаем DS
	@@Answer:
		mov	bx,Answer2F	; возвращаем ответ в регистре BX, если наша программа загружена (или была загружена)
		iret			; выходим из прерывания

RealInt2F:	db	0EAh		; jmp far - переходим к старому обработчику прерывания 2Fh
RealAddr2F	dw	?,?		; адерес прыжка (старого обработчика прерывания)

TSREnd		=	$		; конец резидентной части программы

;-----------------------------------------------------------------------------------------------------------------------

; Установка векторов прерывания
SetIntVec:
		; Проверка опции /U (выгрузка)
		mov	si,81h		; адрес начала командной строки
	@@Skip:	lodsb			; чтение символа в AL, SI=SI+1
		cmp	al,' '		; если это пробел
		je	@@Skip		; переходим к следующему символу (пропускаем пробелы)

		mov	ah,al
		lodsb
		and	al,not 20h	; если второй символ - буква, преобразуем её в заглавную
		cmp	ax,'/U'		; это опция /U (выгрузка)?
		je	@@Uninstall	; прыгаем, если да

		; Проверяем - не была ли загружена программа ранее
		mov	ax,Func2F*256	; AH = номер функции, AL = 0 (наша подфункция проверки программы в памяти)
		mov	bx,Request2F	; BX = запрос
		int	2Fh		; производим запрос к сервисному прерыванию
		cmp	bx,Answer2F	; проверяем наш ответ
		jne	@@Install	; прыгаем, если наша программа ещё не загружена

		lea	dx,MsgAlreadyInst  ; DX = адрес сообщения (программа уже загружена)
	@@ShowMsgAndExit:
		mov	ah,9		; функция вывода сообщения (до '$')
		int	21h		; выводим сообщение
		int	20h		; выходим из программы

		; Выгружаем программу из памяти
	@@Uninstall:
		mov	ax,Func2F*256+80h	; AH = номер функции, AL = 80h (наша подфункция выгрузки программы из памяти)
		mov	bx,Request2F	; BX = запрос
		int	2Fh		; пытаемся выгрузить
		lea	dx,MsgNotInst	; DX = адрес сообщения (программа ещё не загружена, присваиваем заранее)
		cmp	bx,Answer2F	; проверяем ответ
		jne	@@ShowMsgAndExit   ; если ответ не совпадает с нужным, программа ещё не загружена, прыгаем на вывод сообщения и выход
		lea	dx,MsgUninstError  ; DX = адрес сообщения (ошибка выгрузки, присваиваем заранее)
		test	al,al		; проверяем AL (код результата выгрузки)
		jnz	@@ShowMsgAndExit   ; если не ноль, выгрузка не удалась, прыгаем на вывод сообщения и выход		
		lea	dx,MsgUninstalled  ; иначе DX = адрес сообщения об успешной выгрузке
		jmp	@@ShowMsgAndExit   ; выводим сообщение и выходим

	@@Install:
		mov	ax,1017h	; номер функции VGA чтения цветовой палитры (блоком)
		xor	bx,bx		; номер первого цвета (0)
		mov	cx,ColNum	; кол-во цветов
		lea	dx,Palette	; ES:DX = адрес буфера
		int	10h		; читаем значения цветовой палитры для первых ColNum цветов в буфер Palette
		
		mov	ax,3508h	; функция получения вектора прерывания 8 (прерывание от таймера)
		int	21h		; получаем вектор
		mov	RealAddr8[0],bx	; сохраняем смещение
		mov	RealAddr8[2],es	; сохраняем сегмент
		mov	ah,25h		; функция установки обработчика прерывания - записи вектора прерывания (AL=8 не менялся после вызова предыдущей функции 35h)
		lea	dx,Handler8	; DS:DX = адрес нашего обработчика
		int	21h		; устанавливаем наш обработчик

		mov	ax,352Fh	; функция получения вектора прерывания 2F (сервисное прерывание)
		int	21h		; получаем вектор
		mov	RealAddr2F[0],bx  ; сохраняем смещение
		mov	RealAddr2F[2],es  ; сохраняем сегмент
		mov	ah,25h		; функция установки обработчика прерывания - записи вектора прерывания (AL=2Fh не менялся после вызова предыдущей функции 35h)
		lea	dx,Handler2F	; DS:DX = адрес нашего обработчика
		int	21h		; устанавливаем наш обработчик

		mov	ah,49h		; функция освобождения памяти
		mov	es,ds:[2Ch]	; сегмент переменных окружения
		int	21h		; освобождаем сегмент с переменными окружения (чтобы программа занимала меньше памяти)

		mov	ah,9		; функция вывода сообщения (до '$')
		lea	dx,MsgInstalled	; адрес сообщения
		int	21h		; выводим сообщение

		lea	dx,TSREnd	; конец обработчика прерывания
		int	27h		; выходим, оставив программу резидентной

;-----------------------------------------------------------------------------------------------------------------------

MsgInstalled	db	'FadeOut is successfully installed!',13,10
		db	'Run with /U parameter to uninstall.',13,10,'$'
MsgAlreadyInst	db	'FadeOut is already installed!',13,10,'$'
MsgUninstalled	db	'FadeOut is successfully UNinstalled!',13,10,'$'
MsgNotInst	db	'FadeOut is NOT installed yet!',13,10,'$'
MsgUninstError	db	'Can''t uninstall FadeOut :(',13,10,'$'

END		Start
