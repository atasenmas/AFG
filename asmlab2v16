; Программа, работающая с числами типа DWORD (4-байтовыми)

.model small
.486						; поддержка инструкций процессора 486
.stack 100h					; стек на 256 байт

.data

WS		=	4			; размер элемента (4 байта)
Src		DD	-38, -1, 555, -200000, 180000000, 2, -317, 77	; данные
Count		=	($-Src)/WS		; кол-во элементов массива
Dest		DD	Count dup (?)		; буфер под новый массив

.code

Start:

		mov	ax,@data
		mov	ds,ax			; DS = сегмент данных

		mov	eax,[Src]		; EAX = первый элемент массива
		mov	edx,[Src+(Count-1)*WS]	; EDX = последний элемент массива
		cmp	eax,edx			; сравниваем их
		jle	MinAX			; если EAX <= EDX, прыгаем
		xchg	eax,edx			; иначе меняем значения местами, чтобы в EAX был меньший элемент, а в EDX больший
	MinAX:	push	eax			; сохраняем в стеке меньший элемент (среди первого и последнего)
		push	edx			; сохраняем в стеке больший элемент (потом они понадобятся)

		; Обработка исходного массива (Src)
	Repeat:	lea	si,Src			; SI = начало исходного массива, индексный регистр (для индексной адресации)
		xor	bx,bx			; BX = 0 (обмена значений пока не было)
		mov	cx,Count-1		; CX = кол-во элементов массива минус 1
		jcxz	MakeNew			; если массив состоит из 1 элемента, его обрабатывать ненужно (прыгаем)
	CompNext:
		mov	eax,[si]		; AX = элемент массива
		mov	edx,[si+WS]		; DX = следующий элемент массива
		cmp	eax,edx			; сравниваем их
		jle	SkipSwap		; если EAX <= EDX, прыгаем
		mov	ebp,eax
		or	ebp,edx			; EBP = EAX or EDX (нас интересует только старший бит, т.к. у отрицательных чисел старший бит установлен в 1, у положительных - сброшен в 0)
		jns	SkipSwap		; если старший бит EBP = 0, значит оба числа положительные, менять их не надо, прыгаем
		mov	[si],edx		; иначе (если EAX >= EDX и хотя бы одно из чисел отрицательное), меняем...
		mov	[si+WS],eax		; ...их местами
		inc	bx			; увеличиваем счётчик обменов
	SkipSwap:
		add	si,WS			; переходим к следующему числу (добавляем к SI размер числа)
		loop	CompNext		; повторяем цикл CX раз

		test	bx,bx			; проверяем BX (кол-во обменов)
		jnz	Repeat			; повторяем процесс, если BX <> 0 (если был хотя бы один обмен)
	MakeNew:
		; Формируем новый массив
		lea	si,Src			; SI = начало исходного массива, индексный регистр (для индексной адресации)
		lea	bx,Dest			; BX = начало нового массива, базовый регистр (для базовой адресации)
		pop	edx			; EDX = восстанавливаем из стека верхнюю границу значений, который не подходят для нового массива
		pop	eax			; EAX = восстанавливаем из стека нижнюю границу значений, который не подходят для нового массива
		mov	cx,Count		; CX = кол-во элементов массива
	CheckNext:
		mov	ebp,[si]		; EBP = очередной элемент массива
		cmp	ebp,eax			; сравниваем значение с минимальным
		jl	Ok			; прыгаем, если оно меньше (т.е. подходит)
		cmp	ebp,edx			; сравниваем значение с максимальным
		jng	BadNumber		; прыгаем, если оно НЕ больше (т.е. НЕ подходит)
	Ok:	mov	[bx],ebp		; иначе записываем число (которое не попадает в интервал от EAX до EDX) в новый массив
		add	bx,WS			; переходим к следующему числу нового массива (добавляем к BX размер числа)
	BadNumber:
		add	si,WS			; переходим к следующему числу исходного массива (добавляем к SI размер числа)
		loop	CheckNext		; повторяем цикл CX раз (обрабатывая все элементы массива)

		; Завершение
		mov	cx,bx			; CX = адрес элемента, следующего за последним, в новом массиве
		sub	cx,offset Dest		; CX = размер массива в байтах (вычитаем адрес начала)
		shr	cx,2			; делим CX на 4 (размер слова) в помощью сдвига справо
		; Итого в CX имеем размер нового массива

		mov	ax,4C00h
		int	21h			; выходим из программы

end		Start				; Start - точка старта
